    JSR detectHW        ; Find the addresses of HW we care about
    JSR setupMonitor    ; Configure and initialize the monitor
    JSR setupClock      ; Set up the clock to tick at 1/60s
    JSR fillScrollBuffer ; Fill the scroll buffer for the start of the game
    JSR splashScreen    ; Display splash screen and wait for spacebar
    JSR setRandomSeed   ; Set the random seed from the clock
    JSR setupMainLoop   ; Configure mainLoop to be triggered every 1/60s

:infiniteStall
    SET PC, infiniteStall
                        ; Hang here, if everything is golden, we're waiting
                        ; for an interrupt from the clock

; Main loop. Triggered every 1/60s by an interrupt from the clock
:mainLoop
    SET A, 2
    SET B, " "
    HWI [keyboardHWaddr]
        
    IFE I, 20           ; When air time has reached maximum,
    SET C, 0            ; Set keyboard to off
        
    ADD J, 1            ; Increment frame counter (J) per cycle
    MOD J, 20           ; Limit J to be less than 10 to run every 1/6 second
    
    IFE J, 0            ; Increment which frame number
    ADD Z, 1             
    MOD Z, 3            ; Mod for 3 frames of animation

; Scrolling
    JSR scroll
    
; Running
    IFN C, 1
    SET I, 0    
    JSR running

; Jumping    
    IFE C, 1
    IFL I, 10
    JSR jumping

    JSR calcScore

    RFI 0               ; Since mainLoop is technically an interrupt
                        ; service routine, return to where we came from

; Initialize the scroll buffer (at 0x8200) with addresses of tile indices
:fillScrollBuffer
    SET I, 0            ; Start counting from zero
:fillScrollBufferLoop
    SET [0x8200+I], parapetMiddle
                        ; Draw parapets on top row
    SET [0x8220+I], buildingSolidMiddle
                        ; Draw buildings on bottom row
    ADD I, 1            ; Increment I
    IFL I, 32           ; Loop if I less than 32
    SET PC, fillScrollBufferLoop
    SET PC, POP         ; Return from subroutine


; Animate everything in the scroll buffer
:scroll
    SET X, 0            ; Set X to 0, I and J are weirdly in use
    ADD [scrollPosition], 1
                        ; Increment the animation index
    MOD [scrollPosition], 4
                        ; Mod animation index for 4 frames of animation
:scrollLoop
    SET Y, [0x8200+X]   ; Store the base address of the frame in Y
    ADD Y, [scrollPosition]
                        ; Add current animation index to Y
    SET [0x8080+X], [Y] ; Look up VRAM word and write it to VRAM
    ADD X, 1            ; Increment X
    IFL X, 64           ; Loop while X is less than 64
    SET PC, scrollLoop  
    SET PC, POP         ; Return from subroutine

:scrollPosition
    DAT 0

; Use the clock to calculate the users score
:calcScore
    set A, 1            ; Store ticks elapsed since clock reset in C
    HWI [clockHWaddr]   ; Send interrupt to clock
    DIV C, 5
    SET [currentScore], C 
                        ; Set the current score to the clock value
    JSR displayScore    ; Display the calculated digits
    SET PC, POP         ; Return from subroutine

; Display the players current score
:displayScore
    SET X, 0x801f       ; Score display fist digit location
    SET B, 1            ; Digit to display
:displayScoreLoop
    SET Y, 0x042e       ; Initialize digits to zero
    
    SET C, [currentScore] ; Set C to the players Current Score
    DIV C, B            ; Divide by B to "shift" C into the right cut off position
    MOD C, 10           ; Mod by 10 to "cut off" the desired digit
    ADD Y, C            ; Add the score dgit value to the display value
    SET [X], Y          ; Set X to the display digit
    SUB X, 1            ; Move over by one space
    MUL B, 10           ; Move to next digit that needs to be displayed
    IFG X, 0x8019       ; If we are not at the last display location
    SET PC, displayScoreLoop ; Loop back to top
    SET PC, POP         ; Return from subroutine
    
:currentScore            
    DAT 0x0000          ; Player's current score

; Get clock value from start screen to make random generatior
; As random as possible
:setRandomSeed        
    SET A, 1            ; Store number of ticks elapsed since last 
                        ; call to 0 in C register
    HWI [clockHWaddr]   ; Send interrupt to clock
    SET [randomSeed], C ; Save clock value to randomSeed
    SET PC, POP         ; Return from subroutine

; Random number generator
; code from lowey2002 
; http://www.0x10cforum.com/forum/m/4932880/viewthread/2732760-pseudorandom-generator
:random
    SET X, [randomSeed] ; Set x to random seed
    MUL X, 0xe3d1
    ADD X, 0x2b69
    SHR X, 3
    SET [randomSeed], X ; Save new seed
    SET I, [randomMax]
    SUB I, [randomMin]  ; Calc difference between bounds
    MOD X, I            ; Reduces to difference between bounds
    ADD X, [randomMin]  ; Increases to make sure x is above lower bound  
    SET PC, POP         ; Return from subroutin

:randomMin            
    DAT 0x0000          ; Lower bound for random number

:randomMax
    DAT 0x0064          ; Upper bound for random number    

:randomSeed              
    DAT 0x3e42          ; Seed for random number

; Feeds random number generator to get gap size, and starting point
:GapCreator    
    ADD [size], [startingPoint] 
                        ; Add the size and the starting point of the previous gap together
    ADD [size], 5       ; Add three to this number because we do not want gaps that are too close together
    SET [randomMin], [size]
                        ; Set the min distance to this number
    ADD [size] , 40     ; Add 10 more to get a new max
    SET [randomMax], [size]
                        ; Set max to this number
    JSR random          ; Call random num gen for starting
    SET [startingPoint], X
                        ; Save the new starting point
    SET [randomMin], 1  ; Min Number of gap spaces in a row
    SET [randomMax], 5  ; Max number of gap spaces in a row
    JSR random          ; Call random num generator for size
    SET [size], X       ; Save the new size
    SET PC, POP         ; Return from subroutin

:startingPoint
    DAT 0x0000          ; Starting point for gap

:size
    DAT 0x0000          ; Size for gap

:running
    SET [0x8045], [0x1100]
    SET [0x8026], [0x2200]
    SET [0x8047], [0x3300]

    SET [0x8046], [thiefHead+Z]
                        ; Display on 0th frame defined by literal 
    SET [0x8065], [leftBody+Z]
                        ; Display on one row down 
    SET [0x8066], [rightBody+Z]
    SET [0x8067], [pixel+Z]
    SET PC, POP

:jumping
    SET [0x8065], [0x1100]  
    SET [0x8066], [0x1100] 
    SET [0x8067], [0x1100] 

    ADD I,1
    SET [0x8026], [thiefHead+Z]
    SET [0x8045], [leftBody+Z]
                        ; Display on one row down 
    SET [0x8046], [rightBody+Z]
    SET [0x8047], [pixel+Z]
    SET PC, POP

; Display splash screen until spacebar pressed
:splashScreen
    SET A, 2
    SET B,  " "
:splashScreenLoop
    HWI [keyboardHWaddr]
    IFE C, 0
    SET PC, POP
    SET PC, splashScreenLoop
    
; Configures the clock to tick at 1/60s
:setupClock
    SET A, 0            ; Put clock into set frequency mode
    SET B, 1            ; Set clock frequency to 1/60s
    HWI [clockHWaddr]   ; Send settings to the clock
    SET PC, POP         ; Return from subroutine

; Setup mainLoop to be triggered once every clock tick
:setupMainLoop
    IAS mainLoop        ; Set up mainLoop as the interrupt handler
    SET A, 2            ; Put clock into set interrupt mode
    SET B, 1            ; Set clock interrupt message to 1
    HWI [clockHWaddr]   ; Send settings to the clock
    SET PC, POP         ; Return from subroutine

; Configures the monitor and the VRAM for the monitor. Note: time consuming
:setupMonitor
    SET A, 0            ; Put monitor into set VRAM mode
    SET B, 0x8000       ; Set the start of the monitor's VRAM mapping
    HWI [monitorHWaddr] ; Send settings to monitor. The monitor will still
                        ; respond to interrupts while it's powering on
    SET A, 1            ; Put monitor into set font mode
    SET B, monitorFont  ; Set the start of the monitor's font map
    HWI [monitorHWaddr] ; Send settings to monitor
    SET A, 2            ; Put the monitor into set palette mode
    SET B, monitorPalette
                        ; Set the start of the monitor's font map
    HWI [monitorHWaddr] ; Send settings to monitor
    SET PC, POP         ; Return from subroutine

; Scans attached hardware and populates the (device)HWaddr memory locations
; with the address of each recognized attached device.
:detectHW
    HWN I               ; Store the number of attached devices in I
:detectHWaddrLoop       ; Loop through valid HW addresses
    SUB I, 1            ; Decrement I by 1. We do this first, because HWN
                        ; returns the total number of devices, not the
                        ; index of the last device
    HWQ I               ; Load information about device with HW address I
    SET J, 0            ; Reset J to 0, because loop
:detectHWcompLoop       ; Loop through know device IDs, looking for an ID
                        ; match
    IFE [J+detectHWdataLo], A
                        ; See if the low word of the HW ID in A matches the
                        ; Jth known device ID
    IFE [J+detectHWdataHi], B
                        ; See if the high word of HW ID in B matched the
                        ; Jth known device ID
    SET [J+clockHWaddr], I
                        ; Store the HW address of the Jth recognized device
                        ; The label is clockHWaddr because its the first
                        ; in the block
    ADD J, 3            ; Increment J by 3, becuase each block is 3 words
                        ; long
    IFL J, 9            ; Continue looping if J less than 9, as there are
                        ; 3 known devices * 3 words. Hard coded for small
    SET PC, detectHWcompLoop
                        ; Conditionally jump to start of compLoop
    IFG I, 0            ; If I is greater than 0, loop addrLoop
    SET PC, detectHWaddrLoop
                        ; Conditionally jump to start of addrLoop
    SET PC, POP         ; Return from subroutine

; Hardware IDs and addresses. Use detectHW to populate addresses
:detectHWdataLo
    DAT 0xb402          ; Low word of Generic Clock ID
:detectHWdataHi
    DAT 0x12d0          ; High word of Generic Clock ID
:clockHWaddr
    DAT 0xffff          ; To be filled with HW address of clock
    DAT 0x7406, 0x30cf  ; Generic Keyboard ID
:keyboardHWaddr
    DAT 0xffff          ; To be filled with HW address of keyboard
    DAT 0xf615, 0x7349  ; LEM1802 Monitor ID
:monitorHWaddr
    DAT 0xffff          ; To be filled with HW address of monitor

; Definitions for the monitor's color palette
:monitorPalette
    ; Color 0 (black)
    DAT 0x0000
    ; Color 1 (red)
    DAT 0x0e33
    ; Color 2 (person gray)
    DAT 0x0777
    ; Color 3 (building gray)
    DAT 0x0ccc
    ; Color 4 (number white)
    DAT 0x0fff

:monitorFont
;THIEF
    ; Font Char 0
        DAT 0xa0a0, 0x4000
    ; Font Char 1
        DAT 0x0000, 0x90c8
    ; Font Char 2
        DAT 0x0000, 0x84ea
    ; Font Char 3
        DAT 0x3f72, 0x8202
    ; Font Char 4
        DAT 0x0718, 0x2100
    ; Font Char 5
        DAT 0x8080, 0x0000
    ; Font Char 6
        DAT 0x0000, 0x88e4
    ; Font Char 7
        DAT 0x7eca, 0x1110
    ; Font Char 8
        DAT 0x0000, 0x0071
    ; Font Char 9
        DAT 0x0000, 0x01e2
    ; Font Char 10
        DAT 0x0000, 0x8c42
    ; Font Char 11
        DAT 0x3fca, 0x0402
    ; Font Char 12
        DAT 0x0000, 0x8000
    ; Font Char 13
        DAT 0x031c, 0x0000
    ; Font Char 14
        DAT 0x3fc5, 0x0810
    ; Font Char 15
        DAT 0xf454, 0x8840
    ; Font Char 16
        DAT 0x0000, 0x001c
    ; Font Char 17
        DAT 0xe8a8, 0x1080
    ; Font Char 18
        DAT 0x0000, 0x2040
    ; Font Char 19
        DAT 0xd050, 0x2000
    ; Font Char 20
        DAT 0x1fe2, 0x0402
    ; Font Char 21
        DAT 0x0f71, 0x0201
    ; Font Char 22
        DAT 0x0100, 0x0000
    ; Font Char 23
        DAT 0x0000, 0x4080
    ; Font Char 24
        DAT 0x0000, 0x2018
    ; Font Char 25
        DAT 0x0000, 0x0000
    ; Font Char 26
        DAT 0x0000, 0x00e2
    ; Font Char 27
        DAT 0x3fc5, 0x0808
    ; Font Char 28
        DAT 0x4040, 0x8000

  ;BUILDING
    ; Font Char 29
        DAT 0x0000, 0x6202
    ; Font Char 30
        DAT 0x6200, 0x0062
    ; Font Char 31
        DAT 0x07fd, 0x9dff
    ; Font Char 32
        DAT 0x00ff, 0xffff
    ; Font Char 33
        DAT 0xfff8, 0x0262
    ; Font Char 34
        DAT 0xffff, 0xffff
    ; Font Char 35
        DAT 0x0062, 0x6200
    ; Font Char 36
        DAT 0xffff, 0xff00
    ; Font Char 37
        DAT 0xff00, 0x0000
    ; Font Char 38
        DAT 0x0062, 0x02f8
    ; Font Char 39
        DAT 0x02f8, 0xffff
    ; Font Char 40
        DAT 0xffff, 0xf802
    ; Font Char 41
        DAT 0x0000, 0x00ff
    ; Font Char 42
        DAT 0x0000, 0x0000
    ; Font Char 43
        DAT 0x0000, 0x6262
    ; Font Char 44
        DAT 0xffff, 0x0000
    ; Font Char 45
        DAT 0xf8ff, 0xffff

    ;NUMBERS
    ; Font Char 46
        DAT 0x837d, 0x83ff ; 0
    ; Font Char 47
        DAT 0x7b01, 0x7fff ; 1
    ; Font Char 48
        DAT 0x3b4d, 0x73ff ; 2
    ; Font Char 49
        DAT 0xbb6d, 0x93ff ; 3
    ; Font Char 50
        DAT 0xe1ef, 0x01ff ; 4
    ; Font Char 51
        DAT 0xb175, 0x8dff ; 5
    ; Font Char 52
        DAT 0x836d, 0x9bff ; 6
    ; Font Char 53
        DAT 0x3dcd, 0xf1ff ; 7
    ; Font Char 54
        DAT 0x936d, 0x93ff ; 8
    ; Font Char 55
        DAT 0xb36d, 0x83ff ; 9

    ;other turret that we forgot

 ; Font Char 56
    DAT 0x0262, 0x0000
; Font Char 57
    DAT 0xffff, 0xffff
; Font Char 58
    DAT 0x6202, 0xf8ff
; Font Char 59
    DAT 0x6262, 0x0000
; Font Char 60
    DAT 0x0000, 0x0007
; Font Char 61
    DAT 0x0000, 0xffff

;Missing PIX

;Font Char 62
    DAT 0x0400, 0x0000

:blockLeft
    DAT 0x0106
    DAT 0x0101
    DAT 0x0103
    DAT 0x0104
    ;DAT 0x0102
    
:blockRight
    DAT 0x002a
    DAT 0x332a
    DAT 0x332a
    DAT 0x332a
    ;DAT 0x0106
    
:buildingSolidMiddle
    DAT 0x332a
    DAT 0x332a
    DAT 0x332a
    DAT 0x332a
    ;DAT 0x0106
    
:thiefHead ; (1,0)
    DAT 0x2000 ; 0
    DAT 0x201c ; 1
    DAT 0x2000 ; 2
    
:leftBody ; (0,1)
    DAT 0x200a ; 0
    DAT 0x2002 ; 1
    DAT 0x201a ; 2
    
:rightBody ; (1,1)
    DAT 0x2003 ; 0
    DAT 0x201b ; 1
    DAT 0x200b ; 2
    
:pixel ; (2,1)
    DAT 0x1016 ; 0
    DAT 0x103e ; 1
    DAT 0x1016 ; 2

:buildingSolidLeft ; (0, 1)
    DAT 0x332A
    DAT 0x0325 ; (0, 1) fg#1 bg#0 C#37
    DAT 0x032c ; (3, 1) fg#1 bg#0 C#44
    DAT 0x0324 ; (7, 1) fg#0 bg#1 C#34
    DAT 0x0020 ; (10, 1) fg#0 bg#0 C#42

:buildingSolidRight ; (0, 1)
    DAT 0x002A
    DAT 0x3025 ; (0, 1) fg#1 bg#0 C#37
    DAT 0x302c ; (3, 1) fg#1 bg#0 C#44
    DAT 0x3024 ; (7, 1) fg#0 bg#1 C#34
    DAT 0x3320 ; (10, 1) fg#0 bg#0 C#42

:parapetLeft    ;correct
    DAT 0x301F ; (0, 0) fg#1 bg#0 C#31
    DAT 0x0321 ; (3, 0) fg#1 bg#0 C#33
    DAT 0x0328 ; (7, 0) fg#0 bg#1 C#40
    DAT 0x303C ; (10, 0) fg#0 bg#0 C#39 end
    ;DAT 0x3027 ;(1,0) C#60
    
:parapetLeftMiddle
    DAT 0x0323 ;(1,0) C#35
    DAT 0x032b ;(1,0) C#35
    DAT 0x031e ;(1,0) C#35
    DAT 0x0338 ;(1,0) C#35
    
:parapetMiddle
    DAT 0x0323 ;(1,0) C#
    DAT 0x032b ;(1,0) C#
    DAT 0x031e ;(1,0) C#
    DAT 0x033b ;(1,0) C#

:parapetRightMiddle        ;correct
    DAT 0x0326 ;C#38
    DAT 0x031d ;(1,0) C#29
    DAT 0x031e ;(1,0) C#30
    DAT 0x033b ;(1,0) C#59

:parapetRight
    DAT 0x002A ;blank
    DAT 0x032d ;C#45
    DAT 0x0327 ; (3, 0) fg#1 bg#0 C#39
    DAT 0x033a ;C#58

